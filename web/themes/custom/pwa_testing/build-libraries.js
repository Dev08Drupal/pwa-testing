#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");

// Configuraci√≥n
const config = {
  scssDir: "./scss/components",
  cssDir: "./css/components",
  librariesFile: "./pwa_testing.libraries.yml",
  themeFile: "./pwa_testing.theme",
  autoLibrariesFile: "./pwa_testing.auto-libraries.yml",
  autoThemeFile: "./pwa_testing.auto-functions.php",
  themeName: "pwa_testing",
};

// Mapeo de carpetas a prefijos de librer√≠a
const folderToPrefix = {
  paragraph: "paragraph",
  block: "block",
  view: "view",
  node: "node",
  form: "form",
};

/**
 * Debug: Mostrar estructura de archivos
 */
function debugFileStructure() {
  console.log("üîç DEBUG: Estructura de archivos:");

  // Verificar carpeta SCSS
  console.log(`\nüìÅ SCSS Directory: ${config.scssDir}`);
  if (fs.existsSync(config.scssDir)) {
    console.log("   ‚úÖ Existe");
    const scssContent = fs.readdirSync(config.scssDir, { withFileTypes: true });
    scssContent.forEach((item) => {
      if (item.isDirectory()) {
        console.log(`   üìÇ ${item.name}/`);
        const subPath = path.join(config.scssDir, item.name);
        const subFiles = fs.readdirSync(subPath);
        subFiles.forEach((file) => {
          console.log(`      üìÑ ${file}`);
        });
      }
    });
  } else {
    console.log("   ‚ùå No existe");
  }

  // Verificar carpeta CSS
  console.log(`\nüìÅ CSS Directory: ${config.cssDir}`);
  if (fs.existsSync(config.cssDir)) {
    console.log("   ‚úÖ Existe");
    const cssContent = fs.readdirSync(config.cssDir, { withFileTypes: true });
    cssContent.forEach((item) => {
      if (item.isDirectory()) {
        console.log(`   üìÇ ${item.name}/`);
        const subPath = path.join(config.cssDir, item.name);
        if (fs.existsSync(subPath)) {
          const subFiles = fs.readdirSync(subPath);
          subFiles.forEach((file) => {
            const filePath = path.join(subPath, file);
            const stats = fs.statSync(filePath);
            console.log(`      üìÑ ${file} (${stats.size} bytes)`);
          });
        }
      }
    });
  } else {
    console.log("   ‚ùå No existe");
  }

  // Verificar archivos CSS directos
  console.log(`\nüìÅ CSS Root Directory: ./css`);
  if (fs.existsSync("./css")) {
    const rootCssFiles = fs.readdirSync("./css");
    rootCssFiles.forEach((file) => {
      if (file.endsWith(".css")) {
        const filePath = path.join("./css", file);
        const stats = fs.statSync(filePath);
        console.log(`   üìÑ ${file} (${stats.size} bytes)`);
      }
    });
  }
}

/**
 * Leer librer√≠as existentes y separar autom√°ticas de manuales
 */
function parseExistingLibraries() {
  const manualLibraries = {};
  const autoLibraries = {};

  if (fs.existsSync(config.librariesFile)) {
    try {
      const content = fs.readFileSync(config.librariesFile, "utf8");
      console.log(`\nüìÑ Contenido actual de ${config.librariesFile}:`);
      console.log("---");
      console.log(content);
      console.log("---");

      const existingLibraries = yaml.load(content) || {};

      // Separar librer√≠as seg√∫n si son generadas autom√°ticamente
      Object.keys(existingLibraries).forEach((key) => {
        const isAutoGenerated = Object.values(folderToPrefix).some((prefix) => key.startsWith(prefix + "-"));

        if (isAutoGenerated) {
          autoLibraries[key] = existingLibraries[key];
        } else {
          manualLibraries[key] = existingLibraries[key];
        }
      });

      console.log(`\nüìä Librer√≠as encontradas:`);
      console.log(`   Manual: ${Object.keys(manualLibraries).length}`);
      console.log(`   Autom√°ticas: ${Object.keys(autoLibraries).length}`);
    } catch (error) {
      console.warn("‚ö†Ô∏è  Error leyendo librer√≠as existentes:", error.message);
    }
  } else {
    console.log(`‚ùå Archivo no existe: ${config.librariesFile}`);
  }

  return { manualLibraries, autoLibraries };
}

/**
 * Escanear archivos SCSS y generar estructura de librer√≠as
 */
function scanScssFiles() {
  const libraries = {};
  const components = {};

  console.log("\nüîç Escaneando archivos SCSS...");

  // Escanear carpetas de componentes
  Object.keys(folderToPrefix).forEach((folder) => {
    const folderPath = path.join(config.scssDir, folder);
    console.log(`\nüìÇ Procesando carpeta: ${folder}`);
    console.log(`   Ruta: ${folderPath}`);

    if (fs.existsSync(folderPath)) {
      console.log("   ‚úÖ Carpeta existe");
      const files = fs.readdirSync(folderPath);
      components[folder] = [];

      console.log(`   üìÑ Archivos encontrados: ${files.length}`);

      files.forEach((file) => {
        console.log(`   üîç Procesando: ${file}`);

        if (file.endsWith(".scss") && file.startsWith("_")) {
          const componentName = file.replace(/^_/, "").replace(/\.scss$/, "");
          const libraryName = `${folderToPrefix[folder]}-${componentName.replace(/_/g, "-")}`;
          const cssPath = `css/components/${folder}/${componentName}.css`;
          const fullCssPath = path.join(".", cssPath);

          console.log(`      üìù Componente: ${componentName}`);
          console.log(`      üìö Librer√≠a: ${libraryName}`);
          console.log(`      üìÑ CSS esperado: ${cssPath}`);
          console.log(`      üîç Ruta completa: ${fullCssPath}`);

          // Verificar si el archivo CSS existe
          if (fs.existsSync(fullCssPath)) {
            console.log(`      ‚úÖ CSS existe`);

            libraries[libraryName] = {
              css: {
                theme: {
                  [cssPath]: {},
                },
              },
            };

            components[folder].push({
              name: componentName,
              libraryName: libraryName,
              cssPath: cssPath,
            });
          } else {
            console.log(`      ‚ùå CSS no existe: ${fullCssPath}`);

            // Intentar encontrar el archivo en otras ubicaciones
            const alternativePaths = [
              `./css/${componentName}.css`,
              `./css/${folder}/${componentName}.css`,
              `./css/components/${componentName}.css`,
            ];

            console.log(`      üîç Buscando en ubicaciones alternativas:`);
            alternativePaths.forEach((altPath) => {
              if (fs.existsSync(altPath)) {
                console.log(`      ‚úÖ Encontrado en: ${altPath}`);
              } else {
                console.log(`      ‚ùå No existe: ${altPath}`);
              }
            });
          }
        } else {
          console.log(`      ‚è≠Ô∏è  Ignorado (no es _*.scss): ${file}`);
        }
      });

      console.log(`   üìä Componentes v√°lidos encontrados: ${components[folder].length}`);
    } else {
      console.log(`   ‚ùå Carpeta no existe: ${folderPath}`);
    }
  });

  return { libraries, components };
}

/**
 * Generar archivo .libraries.yml preservando c√≥digo manual
 */
function generateLibrariesFile(autoLibraries) {
  console.log("\nüìù Generando archivo .libraries.yml...");

  const { manualLibraries } = parseExistingLibraries();

  // Combinar librer√≠as manuales y autom√°ticas
  const allLibraries = { ...manualLibraries, ...autoLibraries };

  console.log(`üìä Librer√≠as finales:`);
  console.log(`   Manual: ${Object.keys(manualLibraries).length}`);
  console.log(`   Autom√°ticas: ${Object.keys(autoLibraries).length}`);
  console.log(`   Total: ${Object.keys(allLibraries).length}`);

  const yamlContent = yaml.dump(allLibraries, {
    indent: 2,
    lineWidth: 120,
    noRefs: true,
  });

  const header = `# Librer√≠as del tema ${config.themeName}
# 
# SECCI√ìN MANUAL: Las librer√≠as definidas manualmente se preservan
# SECCI√ìN AUTO-GENERADA: Las librer√≠as con prefijos (paragraph-, block-, view-, node-, form-) 
# son generadas autom√°ticamente por build-libraries.js
#
# √öltima generaci√≥n autom√°tica: ${new Date().toISOString()}

`;

  fs.writeFileSync(config.librariesFile, header + yamlContent);
  console.log(`‚úÖ Actualizado: ${config.librariesFile}`);
}

/**
 * Generar funciones PHP autom√°ticas
 */
function generateAutoThemeFunctions(components) {
  console.log("\nüìù Generando funciones PHP autom√°ticas...");

  let phpContent = `<?php

/**
 * @file
 * Funciones autom√°ticamente generadas para el tema ${config.themeName}
 * 
 * ESTE ARCHIVO ES GENERADO AUTOM√ÅTICAMENTE POR build-libraries.js
 * No editar manualmente - los cambios se perder√°n en el pr√≥ximo build
 * 
 * Generado: ${new Date().toISOString()}
 */

use Drupal\\Core\\Form\\FormStateInterface;

`;

  // Generar funci√≥n para p√°rrafos
  if (components.paragraph && components.paragraph.length > 0) {
    console.log(`   üìÑ Generando funci√≥n para ${components.paragraph.length} p√°rrafos`);

    phpContent += `/**
 * Auto-attach libraries for paragraphs.
 */
function ${config.themeName}_auto_preprocess_paragraph(&$variables) {
  $paragraph = $variables['paragraph'];
  $bundle = $paragraph->bundle();
  
  // Mapear tipos de p√°rrafo a librer√≠as (generado autom√°ticamente)
  $paragraph_libraries = [
`;

    components.paragraph.forEach((component) => {
      // Convertir guiones a guiones bajos para el nombre del bundle
      const bundleName = component.name.replace(/-/g, "_");
      phpContent += `    '${bundleName}' => '${config.themeName}/${component.libraryName}',\n`;
      console.log(`      - ${bundleName} ‚Üí ${component.libraryName}`);
    });

    phpContent += `  ];
  
  // Cargar librer√≠a espec√≠fica del p√°rrafo
  if (isset($paragraph_libraries[$bundle])) {
    $variables['#attached']['library'][] = $paragraph_libraries[$bundle];
  }
  
  // A√±adir clases CSS espec√≠ficas
  $variables['attributes']['class'][] = 'paragraph';
  $variables['attributes']['class'][] = 'paragraph--type--' . str_replace('_', '-', $bundle);
  $variables['attributes']['class'][] = 'paragraph--view-mode--' . $variables['view_mode'];
}

`;
  }

  // Generar funci√≥n para bloques
  if (components.block && components.block.length > 0) {
    console.log(`   üìÑ Generando funci√≥n para ${components.block.length} bloques`);

    phpContent += `/**
 * Auto-attach libraries for blocks.
 */
function ${config.themeName}_auto_preprocess_block(&$variables) {
  $block_id = $variables['plugin_id'];
  
  // Mapear bloques a librer√≠as (generado autom√°ticamente)
  $block_libraries = [
`;

    components.block.forEach((component) => {
      // Convertir guiones a guiones bajos para el nombre del bundle
      const bundleName = component.name.replace(/-/g, "_");
      phpContent += `    '${bundleName}' => '${config.themeName}/${component.libraryName}',\n`;
      console.log(`      - ${bundleName} ‚Üí ${component.libraryName}`);
    });

    phpContent += `  ];
  
  // Cargar librer√≠a espec√≠fica del bloque
  if (isset($block_libraries[$block_id])) {
    $variables['#attached']['library'][] = $block_libraries[$block_id];
  }
}

`;
  }

  // Agregar funciones para otros tipos si existen...
  ["view", "node", "form"].forEach((type) => {
    if (components[type] && components[type].length > 0) {
      console.log(`   üìÑ Generando funci√≥n para ${components[type].length} ${type}s`);
      // Agregar funciones espec√≠ficas aqu√≠ si es necesario
    }
  });

  return phpContent;
}

/**
 * Actualizar archivo .theme principal preservando c√≥digo manual
 */
function updateMainThemeFile(components) {
  console.log("\nüìù Actualizando archivo .theme principal...");

  // Generar c√≥digo autom√°tico
  const autoFunctions = generateAutoThemeFunctions(components);

  // Guardar funciones autom√°ticas en archivo separado
  fs.writeFileSync(config.autoThemeFile, autoFunctions);
  console.log(`‚úÖ Generado: ${config.autoThemeFile}`);

  // Leer c√≥digo manual existente si existe
  let manualCode = "";
  if (fs.existsSync(config.themeFile)) {
    const existingContent = fs.readFileSync(config.themeFile, "utf8");

    // Si ya tiene secci√≥n auto-generada, extraer solo la parte manual
    if (existingContent.includes("AUTO-GENERATED SECTION START")) {
      const lines = existingContent.split("\n");
      const manualLines = [];
      let inAutoSection = false;

      for (const line of lines) {
        if (line.includes("AUTO-GENERATED SECTION START")) {
          inAutoSection = true;
          continue;
        }

        if (line.includes("AUTO-GENERATED SECTION END")) {
          inAutoSection = false;
          continue;
        }

        if (!inAutoSection) {
          manualLines.push(line);
        }
      }

      manualCode = manualLines.join("\n").trim();
    } else {
      manualCode = existingContent.trim();
    }
  }

  // Si no hay c√≥digo manual, crear estructura b√°sica
  if (!manualCode) {
    manualCode = `<?php

/**
 * @file
 * Functions to support theming in the ${config.themeName} theme.
 */

use Drupal\\Core\\Form\\FormStateInterface;
use Drupal\\Core\\Template\\Attribute;`;
  }

  // Construir archivo final
  const finalContent =
    manualCode +
    `

// ============================================================================
// AUTO-GENERATED SECTION START - No editar manualmente
// ============================================================================

/**
 * Include auto-generated functions.
 */
require_once __DIR__ . '/pwa_testing.auto-functions.php';

/**
 * Implements hook_preprocess_paragraph() - Integraci√≥n autom√°tica.
 */
function ${config.themeName}_preprocess_paragraph(&$variables) {
  // Llamar funci√≥n autom√°tica si existe
  if (function_exists('${config.themeName}_auto_preprocess_paragraph')) {
    ${config.themeName}_auto_preprocess_paragraph($variables);
  }
  
  // Tu c√≥digo manual para paragraphs puede ir aqu√≠
}

/**
 * Implements hook_preprocess_block() - Integraci√≥n autom√°tica.
 */
function ${config.themeName}_preprocess_block(&$variables) {
  // Llamar funci√≥n autom√°tica si existe
  if (function_exists('${config.themeName}_auto_preprocess_block')) {
    ${config.themeName}_auto_preprocess_block($variables);
  }
  
  // Tu c√≥digo manual para blocks puede ir aqu√≠
}

// ============================================================================
// AUTO-GENERATED SECTION END
// ============================================================================
`;

  fs.writeFileSync(config.themeFile, finalContent);
  console.log(`‚úÖ Actualizado: ${config.themeFile}`);
}

/**
 * Funci√≥n principal
 */
function main() {
  console.log("üîÑ Generando librer√≠as autom√°ticamente (modo debug)...");

  try {
    // Debug de la estructura
    debugFileStructure();

    const { libraries, components } = scanScssFiles();

    // Generar archivo .libraries.yml preservando c√≥digo manual
    generateLibrariesFile(libraries);

    // Actualizar archivo .theme preservando c√≥digo manual
    updateMainThemeFile(components);

    // Mostrar resumen
    console.log("\nüìä Resumen final:");
    Object.keys(components).forEach((folder) => {
      if (components[folder].length > 0) {
        console.log(`  ${folder}: ${components[folder].length} componentes`);
        components[folder].forEach((comp) => {
          console.log(`    - ${comp.name} (${comp.libraryName})`);
        });
      }
    });

    if (Object.keys(components).every((folder) => !components[folder] || components[folder].length === 0)) {
      console.log("\n‚ö†Ô∏è  No se encontraron componentes v√°lidos.");
      console.log("   Verifica que:");
      console.log("   1. Los archivos SCSS est√©n en scss/components/[folder]/");
      console.log("   2. Los archivos empiecen con _ (ejemplo: _mi-componente.scss)");
      console.log("   3. Los archivos CSS correspondientes existan en css/components/[folder]/");
      console.log('   4. Ejecutes "npm run sass-prod" primero para compilar los SCSS');
    } else {
      console.log("\n‚ú® ¬°Librer√≠as generadas exitosamente!");
      console.log(`üìÅ Funciones autom√°ticas: ${config.autoThemeFile}`);
    }
  } catch (error) {
    console.error("‚ùå Error:", error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  main();
}

module.exports = { main, scanScssFiles, generateLibrariesFile };
